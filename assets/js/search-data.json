{
  
  "1": {
    "title": "Anatomy of a snapshot",
    "content": "Anatomy of a snapshot . The AOT snapshot itself is quite complex, it is a custom binary format with no documentation. You may be forced to step through the serialization process manually in a debugger to implement a tool that can read the format. . The source files relevant to snapshot generation can be found here: . Cluster serialization / deserialization [vm/clustered_snapshot.h](https://github.com/dart-lang/sdk/blob/7340a569caac6431d8698dc3788579b57ffcf0c6/runtime/vm/clustered_snapshot.h) [vm/clustered_snapshot.cc](https://github.com/dart-lang/sdk/blob/7340a569caac6431d8698dc3788579b57ffcf0c6/runtime/vm/clustered_snapshot.cc) | ROData serialization [vm/image_snapshot.h](https://github.com/dart-lang/sdk/blob/7340a569caac6431d8698dc3788579b57ffcf0c6/runtime/vm/image_snapshot.h) [vm/image_snapshot.cc](https://github.com/dart-lang/sdk/blob/7340a569caac6431d8698dc3788579b57ffcf0c6/runtime/vm/image_snapshot.cc) | ReadStream / WriteStream [vm/datastream.h](https://github.com/dart-lang/sdk/blob/7340a569caac6431d8698dc3788579b57ffcf0c6/runtime/vm/datastream.h) | Object definitions [vm/object.h](https://github.com/dart-lang/sdk/blob/7340a569caac6431d8698dc3788579b57ffcf0c6/runtime/vm/object.h) | ClassId enum [vm/class_id.h](https://github.com/dart-lang/sdk/blob/7340a569caac6431d8698dc3788579b57ffcf0c6/runtime/vm/class_id.h) | . It took me about two weeks to implement a command line utility that is capable of parsing a snapshot, giving us complete access to the heap of a compiled app. . As an overview, here is the layout of clustered snapshot data: . . Every RawObject* in the Isolate gets serialized by a corresponding SerializationCluster instance depending on its class id. These objects can contain anything from code, instances, types, primitives, closures, constants, etc. More on that later. . After deserializing the VM isolate snapshot, every object in its heap gets added to the Isolate snapshot object pool allowing them to be referenced in the same context. . Clusters are serialized in three stages: Trace, Alloc, and Fill. . In the trace stage, root objects are added to a queue along with the objects they reference in a breadth first search. At the same time a SerializationCluster instance is created corresponding to each class type. . Root objects are a static set of objects used by the vm in the isolate’s ObjectStore which we will use later to locate libraries and classes. The VM snapshot includes StubCode base objects which are shared between all isolates. . Stubs are basically hand written sections of assembly that dart code calls into, allowing it to communicate safely with the runtime. . After tracing, cluster info is written containing basic information about the clusters, most importantly the number of objects to allocate. . In the alloc stage, each clusters WriteAlloc method is called which writes any information needed to allocate raw objects. Most of the time all this method does is write the class id and number of objects that are part of this cluster. . The objects that are part of each cluster are also assigned an incrementing object id in the order they are allocated, this is used later during the fill stage when resolving object references. . You may have noticed the lack of any indexing and cluster size information, the entire snapshot has to be read fully in order to get any meaningful data out of it. So to actually do any reverse engineering you must either implement deserialization routines for 31+ cluster types (which I have done) or extract information by loading it into a modified runtime (which is difficult to do cross-architecture). . Here is a simplified example of what the structure of the clusters would be for an array [123, 42]: . . If an object references another object like an array element, the serializer writes the object id initially assigned during the alloc phase as shown above. . In the case of simple objects like Mints and Smis, they are constructed entirely in the alloc stage because they don’t reference any other objects. . After that the ~107 root refs are written including object ids for core types, libraries, classes, caches, static exceptions and several other miscellaneous objects. . Finally, ROData objects are written which are directly mapped to RawObject*s in-memory to avoid an extra deserialization step. . The most important type of ROData is RawOneByteString which is used for library / class / function names. ROData is also referenced by offset being the only place in the snapshot data where decoding is optional. . Similar to ROData, RawInstruction objects are direct pointers to snapshot data but are stored in the executable instruction symbol rather than main snapshot data. . Here is a dump of serialization clusters that are typically written when compiling an app: . #lint cluster-tbl idx | cid | ClassId enum | Cluster name -|--||- 0 | 5 | Class | ClassSerializationCluster 1 | 6 | PatchClass | PatchClassSerializationCluster 2 | 7 | Function | FunctionSerializationCluster 3 | 8 | ClosureData | ClosureDataSerializationCluster 4 | 9 | SignatureData | SignatureDataSerializationCluster 5 | 12 | Field | FieldSerializationCluster 6 | 13 | Script | ScriptSerializationCluster 7 | 14 | Library | LibrarySerializationCluster 8 | 17 | Code | CodeSerializationCluster 9 | 20 | ObjectPool | ObjectPoolSerializationCluster 10 | 21 | PcDescriptors | RODataSerializationCluster 11 | 22 | CodeSourceMap | RODataSerializationCluster 12 | 23 | StackMap | RODataSerializationCluster 13 | 25 | ExceptionHandlers | ExceptionHandlersSerializationCluster 14 | 29 | UnlinkedCall | UnlinkedCallSerializationCluster 15 | 31 | MegamorphicCache | MegamorphicCacheSerializationCluster 16 | 32 | SubtypeTestCache | SubtypeTestCacheSerializationCluster 17 | 36 | UnhandledException | UnhandledExceptionSerializationCluster 18 | 40 | TypeArguments | TypeArgumentsSerializationCluster 19 | 42 | Type | TypeSerializationCluster 20 | 43 | TypeRef | TypeRefSerializationCluster 21 | 44 | TypeParameter | TypeParameterSerializationCluster 22 | 45 | Closure | ClosureSerializationCluster 23 | 49 | Mint | MintSerializationCluster 24 | 50 | Double | DoubleSerializationCluster 25 | 52 | GrowableObjectArray | GrowableObjectArraySerializationCluster 26 | 65 | StackTrace | StackTraceSerializationCluster 27 | 72 | Array | ArraySerializationCluster 28 | 73 | ImmutableArray | ArraySerializationCluster 29 | 75 | OneByteString | RODataSerializationCluster 30 | 95 | TypedDataInt8Array | TypedDataSerializationCluster 31 | 143 | &lt;instance&gt; | InstanceSerializationCluster ... 54 | 463 | &lt;instance&gt; | InstanceSerializationCluster . There are a few more clusters that could potentially be in a snapshot, but these are the only ones I have seen in a Flutter app so far. . In DartVM there are a static set of predefined class IDs defined in the ClassId enum, 142 IDs as of Dart 2.4.0 to be exact. IDs outside of that (or do not have an associated cluster) are written with separate InstanceSerializationClusters. . Finally bringing the parser together I can view the structure of the snapshot from the ground up, starting with the libraries list in the root object table. . Using the object tree here’s how you can locate a top level function, in this case package:ftest/main.darts main: As you can see above the names of libraries, classes, and functions are included in release snapshots. . Dart can’t really remove them without also obfuscating stack traces, see: https://github.com/flutter/flutter/wiki/Obfuscating-Dart-Code . Obfuscation is probably not worth the effort but this will most likely change in the future and become more streamlined similar to proguard on Android or sourcemaps on the web. . The actual machine code is stored in Instructions objects pointed to by Code objects from an offset to the start of the instruction data. .",
    "url": "/docs/reverse-engineering/anatomy-of-a-snapshot.html",
    "relUrl": "/docs/reverse-engineering/anatomy-of-a-snapshot.html"
  }
  ,"2": {
    "title": "Android Emulator on AMD CPUs",
    "content": "Android Emulator on AMD CPUs . Windows . Do NOT install either HAXM or Hyper-V. | Make sure you have Android Studio 3.2 Beta 1 or higher. | Make sure virtualization is enabled in your BIOS, the option is sometimes labelled SVM. | . Install WHPX . Run optionalfeatures from the start menu, it should open the “Windows Features” dialog. | Check Windows Hypervisor Platform. | Click OK. | Reboot. | After WHPX is installed, the Android Emulator should ‘just work’. . . Linux . Install kvm, it works on AMD out of the box. | . You can use the -accel-check option to check the status of virtualization: . #lint shell ping@debian:~$ Android/sdk/emulator/emulator -accel-check accel: 0 KVM (version 12) is installed and usable. .",
    "url": "/docs/faq/avd-amd.html",
    "relUrl": "/docs/faq/avd-amd.html"
  }
  ,"3": {
    "title": "Countdown",
    "content": "Countdown . In this post we will build a simple countdown that: . Is consistent and accurate. | Continues counting in the background, but not when closed or killed. | Does not rebuild when out of view. | Creating the UI . class CountdownPage extends StatefulWidget { @override _CountdownPageState createState() =&gt; _CountdownPageState(); } class _CountdownPageState extends State&lt;CountdownPage&gt; { /// Formats a duration to &#39;mm:ss&#39;. static String formatDuration(Duration d) =&gt; &#39;${&#39;${d.inMinutes}&#39;.padLeft(2, &#39;0&#39;)}:&#39; &#39;${&#39;${d.inSeconds % 60}&#39;.padLeft(2, &#39;0&#39;)}&#39;; /// Whether or not the widget is counting down. var running = false; /// How long the countdown should be. final duration = Duration(minutes: 5); @override Widget build(BuildContext context) =&gt; Scaffold( appBar: AppBar( backgroundColor: Colors.transparent, elevation: 0, centerTitle: true, title: Text(&#39;Countdown&#39;), actions: [ IconButton( icon: Icon(Icons.settings), onPressed: () { Navigator.of(context).pushNamed(&#39;settings&#39;); }, ) ], ), body: SizedBox.expand(child: Align(child: Column( mainAxisAlignment: MainAxisAlignment.center, crossAxisAlignment: CrossAxisAlignment.center, children: [ Padding( child: Text(formatDuration(duration), style: TextStyle( fontSize: 60, fontFamily: &quot;monospace&quot;, )), padding: EdgeInsets.only(bottom: 50), ), RaisedButton( child: Text(running ? &quot;Stop&quot; : &quot;Start&quot;), onPressed: () =&gt; setState(() { running = !running; }), color: running ? Colors.red : Colors.blue, ), ], ))), ); } . . Counting down . The core of this countdown is timer and endTime, these can tell us when the UI should update and how much time is remaining. . Notice that we aren’t actually counting down, instead we have a specific end time. The remaining time is calculated by subtracting the current and end time, effectively enabling it to continue in the background. . /// How long the countdown should be. var duration = Duration(minutes: 5); /// When the running timer will hit zero. DateTime endTime; /// A timer that periodically fires to update the UI. Timer timer; /// The remaining time before the countdown stops. Duration remainingTime; /// How long until the next tick should fire, i.e. the next time the seconds /// remaining will change. Duration get nextTick =&gt; remainingTime - Duration(seconds: remainingTime.inSeconds); /// Updates the UI and schedules the next tick. void tick() { setState(() {}); remainingTime = endTime.difference(DateTime.now()); if (remainingTime &gt; Duration.zero) { timer = Timer(nextTick, tick); } else { // Countdown is finished! stopCountdown(); } } /// Starts [timer], if not running already. void startTimer() { if (timer != null || !running) return; tick(); } /// Stops [timer], if not stopped already. void stopTimer() { if (timer == null) return; timer.cancel(); timer = null; } /// Starts the countdown void startCountdown() { running = true; endTime = DateTime.now().add(duration); startTimer(); } /// Stops the countdown void stopCountdown() { running = false; stopTimer(); remainingTime = duration; setState(() {}); } . TickerMode . When a page is not visible, the navigator will disable the TickerMode for its subtree. . This is the same mechanism that pauses animations, you can use TickerMode.of(context) to check its state: . @override void didChangeDependencies() { super.didChangeDependencies(); if (TickerMode.of(context)) { startTimer(); } else { stopTimer(); } } . The timer should also stop when the state is disposed: . @override void dispose() { stopTimer(); super.dispose(); } . This will start and stop our timer when the ticker mode changes, preventing the widget from consuming cpu while another page is above it. . Hooking up the UI . The only thing left to do is hook up the UI, first update the countdown text: . child: Text(formatDuration(remainingTime ?? duration), style: TextStyle( fontSize: 60, fontFamily: &quot;monospace&quot;, )), . Then make the button below it call startCountdown / stopCountdown: . RaisedButton( child: Text(running ? &quot;Stop&quot; : &quot;Start&quot;), onPressed: running ? stopCountdown : startCountdown, color: running ? Colors.red : Colors.blue, ), . Final result . Here is a video of the app: . As you can see, the countdown continues running when paused. . With debug prints you can confirm that the timer pauses while the settings menu is open. . Live demo . Here is a link to a live demo on dartpad: https://dartpad.dartlang.org/0d3b02d838120eb57e0c3ad47eb76aad .",
    "url": "/docs/architecture/countdown.html",
    "relUrl": "/docs/architecture/countdown.html"
  }
  ,"4": {
    "title": "CustomScrollView",
    "content": "CustomScrollView . CustomScrollView is a widget that allows you to do create layouts that are dependent on the scroll offset, this is the same mechanism behind widgets like ListView.builder. . Another helpful resource on slivers can be found here: https://flutter.dev/docs/development/ui/advanced/slivers . . ListView.builder . So, you want to make a list like this: . ListView(children: [ Text(&#39;🔥&#39;), ListView.builder( itemCount: 100, itemBuilder: (context, i) =&gt; ListTile( title: Text(&#39;Foo $i&#39;), ), ), ]) . But this causes an error because the inner ListView was given an unbounded height. . The best way to solve this is to convert this into a CustomScrollView: . CustomScrollView(slivers: [ SliverToBoxAdapter( child: Text(&#39;🔥&#39;), ), SliverList( delegate: SliverChildBuilderDelegate( (context, i) =&gt; ListTile( title: Text(&#39;Foo $i&#39;), ), childCount: 100, ), ), ]) . . Going deeper . Sometimes you might want to put your lazily building list inside of something like a card, for example: . CustomScrollView(slivers: [ SliverToBoxAdapter( child: Text(&#39;🔥&#39;), ), Card( child: SliverList( delegate: SliverChildBuilderDelegate( (context, i) =&gt; ListTile( title: Text(&#39;Foo $i&#39;), ), childCount: 100, ), ), ), ]) . Unfortunately, putting a sliver widget inside of a card like this isn’t possible with core Flutter widgets, thankfully I wrote a package that does exactly that: package:boxy. . With this package, we can just replace Card with SliverCard: . CustomScrollView(slivers: [ SliverToBoxAdapter( child: Text(&#39;🔥&#39;), ), SliverCard( child: SliverList( delegate: SliverChildBuilderDelegate( (context, i) =&gt; ListTile( title: Text(&#39;Foo $i&#39;), ), childCount: 100, ), ), ), ]) . This gives us an effect like the following demo, where the children of the SliverList are still dynamically created and destroyed: . . Source code: https://github.com/PixelToast/flutter-boxy/blob/master/example/lib/pages/sliver_container.dart#L121 .",
    "url": "/docs/faq/custom-scroll-view.html",
    "relUrl": "/docs/faq/custom-scroll-view.html"
  }
  ,"5": {
    "title": "Dart defines",
    "content": "Dart defines . If you are looking for a feature similar to environment variables, this is how you implement them. . In Dart code, defines can be accessed through the following methods: . const someInt = int.fromEnvironment(&#39;someInt&#39;); const someBool = bool.fromEnvironment(&#39;someBool&#39;); const someString = String.fromEnvironment(&#39;someString&#39;); . When using the front-end separately, fromEnvironment should only be called in a const expression because it won’t be available at runtime, this includes Flutter apps. . Flutter . Defines in flutter can be passed to run and build: . flutter run --dart-define=someString=foo . flutter build apk --dart-define=someString=foo . Dart . Defines can be passed to the regular dart command through the undocumented -D argument: . dart -DsomeString=foo bin/main.dart . Secret keys . This is not a solution to providing “secret” keys to a Flutter application, if a key is secret then it should not be included at all. . It’s perfectly fine to include public keys in dart code and push them to git, e.g. a token for the Google Maps API. .",
    "url": "/docs/faq/dart-defines.html",
    "relUrl": "/docs/faq/dart-defines.html"
  }
  ,"6": {
    "title": "The Dart SDK",
    "content": "The Dart SDK . Thankfully Dart is completely open source so we don’t have to fly blind when reverse engineering the snapshot format. . Before creating a testbed for generating and disassembling snapshots you have to set up the Dart SDK, there is documentation on how to build it here: https://github.com/dart-lang/sdk/wiki/Building. . You want to generate libapp.so files typically orchestrated by the flutter tool, but there doesn’t seem to be any documentation on how to do that yourself. . The flutter sdk ships binaries for gen_snapshot which is not part of the standard create_sdk build target you usually use when building dart. . It does exist as a separate target in the SDK though, you can build the gen_snapshot tool for arm with this command: . ./tools/build.py -m product -a simarm gen_snapshot . Normally you can only generate snapshots for the architecture you are running on, to work around that they have created sim targets which simulate snapshot generation for the target platform. This has some limitations such as not being able to make aarch64 or x86_64 snapshots on a 32 bit system. . Before making a shared object you have to compile a dill file using the front-end: . ~/flutter/bin/cache/dart-sdk/bin/dart ~/flutter/bin/cache/artifacts/engine/linux-x64/frontend_server.dart.snapshot --sdk-root ~/flutter/bin/cache/artifacts/engine/common/flutter_patched_sdk_product/ --strong --target=flutter --aot --tfa -Ddart.vm.product=true --packages .packages --output-dill app.dill package:foo/main.dart . Dill files are actually the same format as kernel snapshots, their format is specified here: https://github.com/dart-lang/sdk/blob/master/pkg/kernel/binary.md . This is the format used as a common representation of dart code between tools, including gen_snapshot and analyzer. . With the app.dill we can finally generate a libapp.so using this command: . gen_snapshot --causal_async_stacks --deterministic --snapshot_kind=app-aot-elf --elf=libapp.so --strip app.dill . Once you are able to manually generate the libapp.so, it is easy to modify the SDK to print out all of the debug information needed to reverse engineer the AOT snapshot format. . As a side note, Dart was actually designed by some of the people who created JavaScript’s V8 which is arguably the most advanced interpreter ever made. DartVM is incredibly well engineered and I don’t think people give its creators enough credit. .",
    "url": "/docs/reverse-engineering/dart-sdk.html",
    "relUrl": "/docs/reverse-engineering/dart-sdk.html"
  }
  ,"7": {
    "title": "Diagnostics",
    "content": "Diagnostics . Strategy . Always keep the following in mind when deciding whether to do optimizations: . Does the issue exist on a real device in release mode? | Am I sure this piece of code actually impacts frame times? | Are the changes simple or likely to cause other issues? | Will the code still be maintainable? | . The worst thing you can do is premature optimization, spend as much time as possible diagnosing and understanding performance issues before hammering away. . If the problem is complex and only happens when special conditions are met i.e. “user visits page X and gets jank after scrolling down for some time”, it is very helpful to reproduce this issue in a more controlled scenario before making changes. . . Jank . The most noticeable performance issue is Jank, which is when a small number of frames take much longer than they are supposed to. . The symptoms of jank are quite similar, but the underlying issue can vary significantly: . CPU Dart Expensive tasks e.g. parsing markdown | Excessive widget building | Garbage Collection | . | Native code Android APIs | Native views | . | . | GPU dart:ui Too many paint features | Poor handling of Image objects | . | Native code | . | Low memory Loading too many large assets e.g. images | Leaks | . | Power saving Low battery | . | . Sometimes multiple of these factors can impact frames at the same time, remember that if you think you have isolated one. . Performance testing should always be done in profile or release, on IntelliJ that can be configured like this: . .",
    "url": "/docs/performance/diagnostics.html",
    "relUrl": "/docs/performance/diagnostics.html"
  }
  ,"8": {
    "title": "Download Progress",
    "content": "Download Progress . In this post we will build a simple file downloader that shows a visual indication of progress. . . Creating the UI . class MyHomePage extends StatefulWidget { @override _MyHomePageState createState() =&gt; _MyHomePageState(); } class _MyHomePageState extends State&lt;MyHomePage&gt; { var downloading = false; var done = false; double progress; @override Widget build(BuildContext context) =&gt; Scaffold( appBar: AppBar( backgroundColor: Colors.transparent, elevation: 0, centerTitle: true, title: Text(&#39;Downloader&#39;), actions: [ IconButton( icon: Icon(Icons.settings), onPressed: () {}, ) ], ), body: SizedBox.expand(child: Align(child: Column( mainAxisAlignment: MainAxisAlignment.center, crossAxisAlignment: CrossAxisAlignment.center, children: [ if (downloading) SizedBox( width: 120, child: LinearProgressIndicator( value: progress, ), ) else if (done) ...[ Image.network(&#39;https://i.tst.sh/XaY4i.jpg&#39;), Padding( padding: EdgeInsets.all(8), child: RaisedButton( child: Text(&#39;Reset&#39;), onPressed: () { setState(() { done = false; }); }, ), ) ] else RaisedButton( child: Text(&#39;Start&#39;), onPressed: () async { setState(() { downloading = true; progress = null; }); for (int i = 0; i &lt;= 100; i++) { setState(() { progress = i / 100; }); await Future.delayed(Duration(milliseconds: 25)); } setState(() { downloading = false; done = true; }); }, ), ], ))), ); } . This is just a wireframe and does not actually download data. . . Download with progress . Using package:http we can do a streaming download rather than loading it all into memory, this is much more efficient regardless since the data is just going into a file. . Here is a helper class which provides progress updates to a StreamedResponse: . class DownloadTask { /// The length of the download, or null if indeterminate. final int length; /// The current progress of the download, in bytes. final ValueListenable&lt;int&gt; progress; /// The resulting stream of data. final Stream&lt;List&lt;int&gt;&gt; stream; DownloadTask._({ this.length, this.progress, this.stream, }); factory DownloadTask(http.StreamedResponse response) { var progress = ValueNotifier(0); return DownloadTask._( length: response.contentLength, progress: progress, stream: response.stream.map((event) { progress.value += event.length; return event; }), ); } Future&lt;void&gt; save(File file) async { var f = file.openWrite(); await f.addStream(stream); await f.close(); } } . . Hooking up the UI . First, set up new fields in the page state: . /// File path to where the download saves. String filePath; /// An in-progress download task. DownloadTask download; /// Whether or not the download has finished. var done = false; . Then update the progress bar so that it listens to the progress: . if (download != null) SizedBox( width: 120, child: ValueListenableBuilder( valueListenable: download.progress, builder: (context, bytes, child) =&gt; LinearProgressIndicator( value: download.length == null ? null : bytes / download.length, ), ), ) . Make our image actually read from the file: . else if (done) ...[ Image.file(File(filePath)), . Finally, implement the download button: . RaisedButton( child: Text(&#39;Start&#39;), onPressed: () async { // Ignore button press if a download is already in progress. if (download != null) return; // The http client must be disposed after use, we use a // try/finally to make sure it gets disposed properly. http.Client client; try { client = http.Client(); // Start the download task using client.send. download = await DownloadTask(await client.send(http.Request( &#39;GET&#39;, Uri.parse(&#39;https://i.tst.sh/XaY4i.jpg&#39;) ))); // Safely notify the UI that we have a download in progress. if (mounted) setState(() {}); // Compute the file path with package:path and package:path_provider. filePath = path.join( (await getApplicationDocumentsDirectory()).path, &#39;birb.jpg&#39;, ); // Pipe the download into a file at filePath. await download.save(File(filePath)); // Safely notify the UI that the download is complete. if (mounted) setState(() { download = null; done = true; }); } catch (e, bt) { print(&#39;Error: $e n$bt&#39;); // An error has occurred, cancel the download. if (mounted) setState(() { download = null; done = false; }); } finally { client?.close(); } }, ), . . Final result . This video shows the app downloading and displaying a real image: . Source code: https://gist.github.com/PixelToast/a9d539511726fb445d272a13f1f2729d .",
    "url": "/docs/architecture/download-progress.html",
    "relUrl": "/docs/architecture/download-progress.html"
  }
  ,"9": {
    "title": "Efficient painter",
    "content": "Efficient painter . So, you are building a simple drawing app but are struggling to make it performant. . . What is painting? . Painting is simply the process of recording commands to a canvas. . More specifically, when you call methods like Canvas.drawLine all that happens is a small command is written to a list somewhere internally, it is not actually rasterized by the GPU. . Because of this, persisting paints across multiple frames is not as simple as using the same canvas, you are always going to pay O(n) each frame (where n is the number of features). . . A basic example . Here is a very simple example where we collect a list of points using a GestureDetector and paint them as circles with a CustomPainter: . class _HomePageState extends State&lt;HomePage&gt; { var points = &lt;Offset&gt;[]; void clear() { setState(() { points.clear(); }); } build(context) =&gt; Scaffold( appBar: AppBar( title: Text(&quot;Painter&quot;), actions: [ IconButton( icon: Icon(Icons.clear), onPressed: clear, ), ], ), body: LayoutBuilder(builder: (context, constraints) { var size = constraints.constrain(Size.infinite); return GestureDetector( child: CustomPaint( painter: DrawingPainter(points), size: size, willChange: true, ), onPanUpdate: (drag) { setState(() { points.add(drag.localPosition); }); } ); }), ); } class DrawingPainter extends CustomPainter { final List&lt;Offset&gt; points; DrawingPainter(this.points); paint(canvas, size) { for (var pt in points) { canvas.drawCircle(pt, 8, Paint()..color = Colors.blue); } } shouldRepaint(DrawingPainter old) =&gt; true; } . And this feels pretty smooth, at least until we reach a few thousand points or so. . By graphing how long it takes each frame to render, we can see that every call to drawCircle costs us around 2 microseconds on the raster thread: . . The goal is to make the frame time constant instead of linear, and to do that we can use PictureRecorder. . . PictureRecorder . Using PictureRecorder is quite simple, we just pass it to a Canvas, call endRecording and then finally turn the picture into an Image: . Future&lt;ui.Image&gt; bakeCircle() { var recorder = ui.PictureRecorder(); var canvas = ui.Canvas(recorder); canvas.drawCircle(Offset(16, 16), 8, Paint()..color = Colors.blue); var picture = recorder.endRecording(); return picture.toImage(32, 23); } . Using this, we can paint our circles to a raw image instead of to the CustomPainter directly: . class _HomePageState extends State&lt;HomePage&gt; { ui.Image image; var points = &lt;Offset&gt;[]; var baking = false; void clear() { setState(() { baking = false; image = null; points = []; }); } Size size; double scale; void bake() async { if (baking) return; baking = true; var points = this.points; var numPoints = points.length; var recorder = ui.PictureRecorder(); var canvas = ui.Canvas(recorder); canvas.scale(scale); DrawingPainter(image).paint(canvas, size); for (var pt in points) { canvas.drawCircle(pt, 8, Paint()..color = Colors.blue); } var picture = recorder.endRecording(); var newImage = await picture.toImage( (size.width * scale).ceil(), (size.height * scale).ceil(), ); if (points == this.points) { image?.dispose(); setState(() { image = newImage; }); points.removeRange(0, numPoints); baking = false; if (points.isNotEmpty) { return bake(); } } } build(context) =&gt; Scaffold( appBar: AppBar( title: Text(&quot;Painter&quot;), actions: [ IconButton( icon: Icon(Icons.clear), onPressed: clear, ), ], ), body: LayoutBuilder(builder: (context, constraints) { size = constraints.biggest; scale = MediaQuery.of(context).devicePixelRatio; return GestureDetector( child: CustomPaint( painter: DrawingPainter(image), size: size, willChange: true, ), onPanUpdate: (drag) { points.add(drag.localPosition); bake(); }, ); }), ); } class DrawingPainter extends CustomPainter { final ui.Image image; DrawingPainter(this.image); paint(canvas, size) { if (image != null) { canvas.drawImageRect( image, Offset.zero &amp; Size(image.width.toDouble(), image.height.toDouble()), Offset.zero &amp; size, Paint(), ); } } shouldRepaint(DrawingPainter old) =&gt; true; } . Because we paint to an image, this example does not degrade in performance over time. . But there is another problem, the time it takes to call toImage is so long that the image lags behind your actual touch (indicated by the red dot): . This problem can be mitigated by combining both of the above approaches, where we paint points in our CustomPainter but also render them to an image periodically. . . An efficient example . With a relatively simple heuristic, mixing both PictureRecorder and a regular CustomPainter gives us an efficient solution: . class _HomePageState extends State&lt;HomePage&gt; { // The raw pixels of the canvas we create with Picture.toImage, or null. ui.Image image; // The queue of points that we should paint to the canvas. var points = &lt;Offset&gt;[]; // Whether or not we are currently converting the canvas to an image. var baking = false; void clear() { setState(() { baking = false; image = null; points = []; }); } // The size of the current widget, in logical pixels. Size size; // The ratio of physical pixels to logical pixels. double scale; void bake() async { // When the points reach a certain point, we record and render the // canvas to an image. if (points.length &gt; 50 &amp;&amp; !baking) { // Make sure we are only rendering one image at a time. baking = true; // The points instance will change if the clear button is pressed, // keep a copy around just in case. var points = this.points; // New points can be added while we wait for toImage to complete, so // we need to keep track of how many points are rendered. var numPoints = points.length; var recorder = ui.PictureRecorder(); var canvas = ui.Canvas(recorder); // Use the same logical pixel scaling as our widget. canvas.scale(scale); // Invoke our CustomPainter. DrawingPainter(image, points).paint(canvas, size); // Finally render the image, this can take about 8 to 25 milliseconds. var picture = recorder.endRecording(); var newImage = await picture.toImage( (size.width * scale).ceil(), (size.height * scale).ceil(), ); // The clear button might have been pressed before toImage completes, // only apply the new image if the points instance matches what we // started with. if (points == this.points) { // Always dispose image objects when we don&#39;t need them anymore, // this should allow us to re-use the same buffers as the previous // frames. image?.dispose(); // We don&#39;t need to setState here because the next paint would look // identical. image = newImage; // Remove the points we have already rendered, shifting down any // that were added after the toImage started. points.removeRange(0, numPoints); baking = false; } } } build(context) =&gt; Scaffold( appBar: AppBar( title: Text(&quot;Painter&quot;), actions: [ IconButton( icon: Icon(Icons.clear), onPressed: clear, ), ], ), body: LayoutBuilder(builder: (context, constraints) { size = constraints.biggest; scale = MediaQuery.of(context).devicePixelRatio; // Use GesutreDetector&#39;s onPanUpdate to detect taps, same as the previous // example. return GestureDetector( child: CustomPaint( painter: DrawingPainter(image, points), size: size, willChange: true, ), onPanUpdate: (drag) { setState(() { points.add(drag.localPosition); }); bake(); }, ); }), ); } class DrawingPainter extends CustomPainter { final ui.Image image; final List&lt;Offset&gt; points; DrawingPainter(this.image, this.points); paint(canvas, size) { if (image != null) { // Draw our baked image, scaling it down with drawImageRect. canvas.drawImageRect( image, Offset.zero &amp; Size(image.width.toDouble(), image.height.toDouble()), Offset.zero &amp; size, Paint(), ); } // Paint any unbaked points. for (var pt in points) { canvas.drawCircle(pt, 8, Paint()..color = Colors.blue); } } shouldRepaint(DrawingPainter old) =&gt; true; } . Finally, we have the same performance as our first example but without degrading over time. .",
    "url": "/docs/architecture/efficient-painter.html",
    "relUrl": "/docs/architecture/efficient-painter.html"
  }
  ,"10": {
    "title": "experiment_not_enabled",
    "content": "experiment_not_enabled . You have gotten this warning, or something similar: . This requires the &#39;control-flow-collections&#39; experiment to be enabled. Try enabling this experiment by adding it to the command line when compiling and running.dart(experiment_not_enabled) . Do NOT modify analysis options to enable experiments like the message suggests. . The real issue is that your dart version constraint is too low, the solution is to upgrade it in your pubspec: . environment: sdk: &#39;&gt;=2.7.0 &lt;3.0.0&#39; . After you raise the version constraint, don’t forget to run pub get and restart your IDE. .",
    "url": "/docs/faq/experiment-not-enabled.html",
    "relUrl": "/docs/faq/experiment-not-enabled.html"
  }
  ,"11": {
    "title": "Hello, World!",
    "content": "Hello, World! . Cool, we can locate functions by name but how do we figure out what they actually do? . As expected reverse engineering from here on is a bit more difficult because we are digging through the assembly code contained in Instructions objects. . Instead of using a modern compiler backend like clang, Dart actually uses its JIT compiler for code generation but with a couple AOT specific optimizations. . If you have never worked with JIT code, it is a bit bloated in some places compared to what the equivalent C code would produce. Not that Dart is doing a bad job though, it’s designed to be generated quickly at runtime and the hand-written assembly for common instructions often beats clang/gcc in terms of performance. . Generated code being less micro-optimized actually works heavily to our advantage since it closer resembles the higher level IR used to generate it. . Most of the relevant code generation can be found in: . vm/compiler/backend/il_&lt;arch&gt;.cc | vm/compiler/assembler/assembler_&lt;arch&gt;.cc | vm/compiler/asm_intrinsifier_&lt;arch&gt;.cc | vm/compiler/graph_intrinsifier_&lt;arch&gt;.cc | . Here is the register layout and calling conventions for dart’s A64 assembler: . #lint reg-tbl r0 | | Returns r0 - r7 | | Arguments r0 - r14 | | General purpose r15 | sp | Dart stack pointer r16 | ip0 | Scratch register r17 | ip1 | Scratch register r18 | | Platform register r19 - r25 | | General purpose r19 - r28 | | Callee saved registers r26 | thr | Current thread r27 | pp | Object pool r28 | brm | Barrier mask r29 | fp | Frame pointer r30 | lr | Link register r31 | zr | Zero / CSP . This ABI follows the standard AArch64 calling conventions here but with a few global registers: . R26 / THR: Pointer to the running vm Thread, see vm/thread.h | R27 / PP: Pointer to the ObjectPool of the current context, see vm/object.h | R28 / BRM: The barrier mask, used for incremental garbage collection | . Similarly, this is the register layout for A32: . #lint reg-tbl r0 - r1 | | Returns r0 - r9 | | General purpose r4 - r10 | | Callee saved registers r5 | pp | Object pool r10 | thr | Current thread r11 | fp | Frame pointer r12 | ip | Scratch register r13 | sp | Stack pointer r14 | lr | Link register r15 | pc | Program counter . While A64 is a more common target I’ll mostly be covering A32 since its is simpler to read and disassemble. . You can view the IR along with the disassembly by passing --disassemble-optimized to gen_snapshot, but note this only works on the debug/release targets and not product. . As an example, when compiling hello world: . void hello() { print(&quot;Hello, World!&quot;); } . Scrolling down a bit in the disassembly you will find: . #lint dartvm-dasm Code for optimized function &#39;package:dectest/hello_world.dart_::_hello&#39; { ;; B0 ;; B1 ;; Enter frame 0xf69ace60 e92d4800 stmdb sp!, {fp, lr} 0xf69ace64 e28db000 add fp, sp, #0 ;; CheckStackOverflow:8(stack=0, loop=0) 0xf69ace68 e59ac024 ldr ip, [thr, #+36] 0xf69ace6c e15d000c cmp sp, ip 0xf69ace70 9bfffffe blls +0 ; 0xf69ace70 ;; PushArgument(v3) 0xf69ace74 e285ca01 add ip, pp, #4096 0xf69ace78 e59ccfa7 ldr ip, [ip, #+4007] 0xf69ace7c e52dc004 str ip, [sp, #-4]! ;; StaticCall:12( print&lt;0&gt; v3) 0xf69ace80 ebfffffe bl +0 ; 0xf69ace80 0xf69ace84 e28dd004 add sp, sp, #4 ;; ParallelMove r0 &lt;- C 0xf69ace88 e59a0060 ldr r0, [thr, #+96] ;; Return:16(v0) 0xf69ace8c e24bd000 sub sp, fp, #0 0xf69ace90 e8bd8800 ldmia sp!, {fp, pc} 0xf69ace94 e1200070 bkpt #0x0 } . What is printed here is slightly different from a snapshot built in product but the important part is that we can see the IR instructions alongside assembly. . Breaking it down: . #lint dartvm-dasm ;; Enter frame 0xf6a6ce60 e92d4800 stmdb sp!, {fp, lr} 0xf6a6ce64 e28db000 add fp, sp, #0 . This is a standard function prologue, the frame pointer of the caller and link register are pushed to the stack after which the frame pointer is set to the bottom of the function stack frame. . As with the standard ARM ABI, this uses a full-descending stack meaning it grows backwards in memory. . #lint dartvm-dasm ;; CheckStackOverflow:8(stack=0, loop=0) 0xf6a6ce68 e59ac024 ldr ip, [thr, #+36] 0xf6a6ce6c e15d000c cmp sp, ip 0xf6a6ce70 9bfffffe blls +0 ; 0xf6a6ce70 . This is a simple routine which does what you probably guessed, checks if the stack overflowed. . Sadly their disassembler does not annotate either thread fields or branch targets so you have to do some digging. . A list of field offsets can be found in vm/compiler/runtime_offsets_extracted.h, which defines Thread_stack_limit_offset = 36 telling us that the field accessed is the threads stack limit. . After the stack pointer is compared, it calls the stackOverflowStubWithoutFpuRegsStub stub if it has overflowed. The branch target in the disassembly appears to be un-patched but we can still inspect the binary afterwards to confirm. . #lint dartvm-dasm ;; PushArgument(v3) 0xf6a6ce74 e285ca01 add ip, pp, #4096 0xf6a6ce78 e59ccfa7 ldr ip, [ip, #+4007] 0xf6a6ce7c e52dc004 str ip, [sp, #-4]! . Here an object from the object pool is pushed onto the stack. Since the offset is too big to fit in an ldr offset encoding it uses an extra add instruction. . This object is in fact our “Hello, World!” string as a RawOneByteString* stored in the globalObjectPool of our isolate at offset 8103. . You may have noticed that offsets are misaligned, this is because object pointers are tagged with kHeapObjectTag from vm/pointer_tagging.h, in this case all of the pointers to RawObjects in compiled code are offset by 1. . #lint dartvm-dasm ;; StaticCall:12( print&lt;0&gt; v3) 0xf6a6ce80 ebfffffe bl +0 ; 0xf6a6ce80 0xf6a6ce84 e28dd004 add sp, sp, #4 . Here print is called followed by the string argument being popped from the stack. . Like before the branch hasn’t been resolved, it is a relative branch to the entry point for print in dart:core. . #lint dartvm-dasm ;; ParallelMove r0 &lt;- C 0xf69ace88 e59a0060 ldr r0, [thr, #+96] . Null is loaded into the return register, 96 being the offset to the null object field in a Thread. . #lint dartvm-dasm ;; Return:16(v0) 0xf69ace8c e24bd000 sub sp, fp, #0 0xf69ace90 e8bd8800 ldmia sp!, {fp, pc} 0xf69ace94 e1200070 bkpt #0x0 . And finally the function epilogue, the stack frame is restored along with any callee-saved registers. Since lr was pushed last, popping it into pc will cause the function to return. . From now on I’ll be using snippets from my own disassembler which has less problems than the builtin one. .",
    "url": "/docs/reverse-engineering/hello-world.html",
    "relUrl": "/docs/reverse-engineering/hello-world.html"
  }
  ,"12": {
    "title": "Ignoring overflow",
    "content": "Ignoring overflow . The only two widgets that throw this error are Flex (Row / Column) and UnconstrainedBox, the former is obviously the most common. . The problem is not actually the fault of the Flex itself, rather the constraints given by its parent. In order to solve this issue the main axis constraint needs to either be unbounded i.e. have a maximum main axis size of double.infinity or have a clipBehavior of Clip.none. . The simplest way to ignore overflow is to use Flex instead, and set the clip: . Flex( direction: Axis.horizontal, clipBehavior: Clip.none, children: [ Some(), Long(), Widgets(), ], ) . Or using OverflowBox: . OverflowBox( maxWidth: double.infinity, child: Row(children: [ Some(), Long(), Widgets(), ]), ) . I’ve seen some people use Wrap to achieve a similar result, I highly discourage that because the fact that Wrap doesn’t check for overflow is probably an oversight and may change in the future. .",
    "url": "/docs/faq/ignore-overflow.html",
    "relUrl": "/docs/faq/ignore-overflow.html"
  }
  ,"13": {
    "title": "FAQ",
    "content": "FAQ . A bunch of commonly asked questions on Discord. .",
    "url": "/docs/faq/",
    "relUrl": "/docs/faq/"
  }
  ,"14": {
    "title": "Design",
    "content": "Design . My uninformed opinions on design. .",
    "url": "/docs/design/",
    "relUrl": "/docs/design/"
  }
  ,"15": {
    "title": "Architecture",
    "content": "Architecture . These are a set of core state management patterns I use in Flutter, most of these patterns are inspired from the Flutter framework itself. . The biggest goal of this category is to provide patterns that make code simpler, and by extension your life easier. . I encourage people to use the core patterns the framework before trying to force idioms from other ecosystems into it, it is very important to take your time and think critically. . . Dart . By far the most underrated tools for state management are core features in Dart itself, I highly recommend reading through the following if you have not already: . Language Tour - A tour of Dart’s basic syntax. | dart:async - Documentation for the dart:async library | Iterable - The thing that make lists do the thing. | . Clever usage of Streams and Iterables will save you an insane amount of work, reading and practicing them are well worth the time. .",
    "url": "/docs/architecture/",
    "relUrl": "/docs/architecture/"
  }
  ,"16": {
    "title": "Performance",
    "content": "Performance . This category is about performance related topics like best practices and debugging. .",
    "url": "/docs/performance/",
    "relUrl": "/docs/performance/"
  }
  ,"17": {
    "title": "Framework",
    "content": "Framework . Information about framework and engine internals, e.g. Element, RenderObject, Canvas. . Here are some useful resources on this topic: . Technical Overview - An official overview of flutter internals. | Flutter’s Rendering Pipeline - A video describing the render layer in-depth. | How Flutter Renders Widgets - A video describing how the widget layer works. | Flutter’s Layered Design - Similar to the video above, but a bit older. | flutterinternals.org - A community maintained wiki page with some helpful articles. | .",
    "url": "/docs/framework/",
    "relUrl": "/docs/framework/"
  }
  ,"18": {
    "title": "Packages",
    "content": "Packages . Here are some packages I have published: . boxy . This library provides several widgets and utilities that enable you to create advanced layouts without in-depth knowledge of the framework and minimal boilerplate. . pub.dev github . . async_builder . This package provides AsyncBuilder, a widget similar to StreamBuilder / FutureBuilder which is designed to reduce boilerplate and improve error handling. . It also provides InitBuilder, which makes it easier to start async tasks safely. . pub.dev github . . spa . This is a Dart implementation of the Solar Position Algorithm (SPA) by Ibrahim Reda and Afshin Andreas which is used by the U.S. government for radiology and energy purposes. See the paper here: https://www.nrel.gov/docs/fy08osti/34302.pdf . Given an observers coordinates and DateTime it can calculate the position of the sun and other information such as when the sun rises and sets. . pub.dev github .",
    "url": "/docs/packages/",
    "relUrl": "/docs/packages/"
  }
  ,"19": {
    "title": "Reverse Engineering",
    "content": "Most of this section is part of my blog post, you can check it out here. . Reverse Engineering . To start this journey I’ll cover some backstory on the Flutter stack and how it works. . What you probably already know: Flutter was built from the ground up with its own render pipeline and widget library, allowing it to be truly cross platform and have a consistent design and feel no matter what device its running on. . Unlike most platforms, all of the essential rendering components of the flutter framework (including animation, layout, and painting) are fully exposed to you in package:flutter. . You can see these components in the official architecture diagram from wiki/The-Engine-architecture: . . From a reverse engineering perspective the most interesting part is is the Dart layer since that is where all of the app logic sits. . But what does the Dart layer look like? . Flutter compiles your Dart to native assembly code and uses formats that have not been publicly documented in-depth let alone fully decompiled and recompiled. . For comparison other platforms like React Native just bundle minified javascript which is trivial to inspect and modify, additionally the bytecode for Java on Android is well documented and there are many free decompilers for it. . Despite the lack of obfuscation (by default) or encryption, Flutter apps are still extremely difficult to reverse engineer at the moment since it requires in-depth knowledge of Dart internals to even scratch the surface. . This makes Flutter very good from an intellectual property perspective, your code is almost safe from prying eyes. Next I’ll show you the build process of Flutter applications and explain in detail how to reverse engineer the code that it produces. .",
    "url": "/docs/reverse-engineering/",
    "relUrl": "/docs/reverse-engineering/"
  }
  ,"20": {
    "title": "About",
    "content": "About - ping’s cookbook . This site is where I post helpful information about Flutter and Dart. . If you have any questions, feel free to ping me on Discord, my username is ping#0001. . . Categories . FAQ Reverse Engineering Architecture Framework Performance Packages Design .",
    "url": "/",
    "relUrl": "/"
  }
  ,"21": {
    "title": "IntelliJ Observatory",
    "content": "IntelliJ Observatory . The Flutter plugin removed the ability to open the observatory, this is quite annoying. . Here is a tampermonkey script that puts an observatory button on the top right of DevTools: . // ==UserScript== // @name DevTools Observatory button // @namespace https://me.tst.sh/ // @version 0.1 // @description try to take over the world! // @author ping // @match http://127.0.0.1:*/?ide=* // @grant none // ==/UserScript== (function() { &#39;use strict&#39;; function getQueryVariable(variable) { var query = window.location.search.substring(1); var vars = query.split(&#39;&amp;&#39;); for (var i = 0; i &lt; vars.length; i++) { var pair = vars[i].split(&#39;=&#39;); if (decodeURIComponent(pair[0]) == variable) { return decodeURIComponent(pair[1]); } } console.log(&#39;Query variable %s not found&#39;, variable); } var uri = getQueryVariable(&quot;uri&quot;); console.log(&quot;Observatory url: &quot; + uri); document.querySelector(&quot;#try-flutter-web-devtools&quot;).parentElement.insertAdjacentHTML( &#39;beforeend&#39;, &#39;&lt;div class=&quot;masthead-item action-button active&quot; id=&quot;open-observatory&quot; title=&quot;Open Observatory&quot;&gt;&lt;span class=&quot;octicon octicon-clock&quot;&gt;&lt;/span&gt;&lt;/div&gt;&#39; ); var openObservatory = document.querySelector(&quot;#open-observatory&quot;); openObservatory.onclick = function () { location.href = uri; } })(); .",
    "url": "/docs/faq/intellij-observatory.html",
    "relUrl": "/docs/faq/intellij-observatory.html"
  }
  ,"22": {
    "title": "MediaQuery",
    "content": "MediaQuery .",
    "url": "/docs/design/mediaquery.html",
    "relUrl": "/docs/design/mediaquery.html"
  }
  ,"23": {
    "title": "Nesting async builders",
    "content": "Nesting async builders . Basic nesting . Sometimes you might want a widget to depend on the result of multiple asynchronous tasks, including having one request depend on the result of another. . In this example we are calling getUser with a userId string to get a User object, then once that is complete we call user.searchFriends to get a Friends, finally once that is complete we build a Text that uses them: . build(context) =&gt; InitBuilder.arg&lt;Future&lt;User&gt;, String&gt;( getter: getUser, arg: userId, builder: (context, future) =&gt; AsyncBuilder&lt;User&gt;( future: future, waiting: (context) =&gt; CircularProgressIndicator(), builder: (context, user) =&gt; InitBuilder.arg&lt;Future&lt;Friends&gt;, String&gt;( getter: user.searchFriends, arg: queryString, builder: (context, future) =&gt; AsyncBuilder&lt;Friends&gt;( future: future, waiting: (context) =&gt; CircularProgressIndicator(), builder: (context, friends) =&gt; Text(&#39;Name: ${user.name} Friends: $friends&#39;), ), ), ), ); . Other than being ugly, this can also cause the progress indicator to look like its stuttering as it would get re-created when the first future completes. . What you should do instead is make a function that completes with every value required by the UI at once: . static Tuple2&lt;User, Friends&gt; getUserAndFriends( String userId, String queryString, ) async { var user = await getUser(userId); var friends = await user.searchFriends(queryString); return Tuple2(user, friends); } build(context) =&gt; InitBuilder.arg2&lt;Future&lt;Tuple2&lt;User, Friends&gt;&gt;, String, String&gt;( getter: getUserAndFriends, arg1: userId, arg2: queryString, builder: (context, future) =&gt; AsyncBuilder( future: future, builder: (context, tuple) =&gt; Text(&#39;Name: ${tuple.item1.name} Friends: ${tuple.item2}&#39;), ), ); . In this case we’re using a Tuple2 from package:tuple to return two values at the same time. . . Streams . Another common problem is when you build widgets from a stream, but then need to make another request depending on the information from the stream. . In this example, we take a stream of Users rather than a future, but requests Friends in the same way: . build(context) =&gt; InitBuilder&lt;Stream&lt;User&gt;, String&gt;( getter: getUsers, builder: (context, stream) =&gt; AsyncBuilder( stream: stream, waiting: (context) =&gt; CircularProgressIndicator(), builder: (context, user) =&gt; InitBuilder.arg&lt;String, Friends&gt;( getter: user.searchFriends, arg: queryString, builder: (context, future) =&gt; AsyncBuilder( future: future, waiting: (context) =&gt; CircularProgressIndicator(), builder: (context, friends) =&gt; Text(&#39;Name: ${user.name} Friends: $friends&#39;), ), ), ), ); . What you can do instead is use Stream.asyncMap to add friends to the stream so that we only need a single builder: . static Stream&lt;Tuple2&lt;User, Friends&gt;&gt; getUsersAndFriends( String queryString, ) =&gt; getUsers().asyncMap((user) async =&gt; Tuple2(user, await user.getFriends(queryString))); build(context) =&gt; InitBuilder.arg&lt;Stream&lt;Tuple2&lt;User, Friends&gt;&gt;, String&gt;( getter: getUsersAndFriends, arg: queryString, builder: (context, stream) =&gt; AsyncBuilder( stream: stream, waiting: (context) =&gt; CircularProgressIndicator(), builder: (context, tuple) =&gt; Text(&#39;Name: ${tuple.item1.name} Friends: ${tuple.item2}&#39;), ), ); .",
    "url": "/docs/architecture/nesting-async-builders.html",
    "relUrl": "/docs/architecture/nesting-async-builders.html"
  }
  ,"24": {
    "title": "Project Structure",
    "content": "Project Structure . My rule of thumb is that given an idea of a particular feature, i.e. a specific page or service, you should be able to find the file its in through auto completion alone. . If you lack inspiration, here are some folder structures I use: . theme/buttons.dart theme/text_input.dart theme.dart auth/auth_service.dart auth/auth_impl.dart utils/color_utils.dart utils/state_utils.dart utils.dart common/potato_card.dart common/foo_widget.dart common.dart profile/profile_service.dart profile/profile.dart profile/user.dart profile/member.dart profile/guild.dart profile.dart pages/home/home_page.dart pages/home/cards/foo_card.dart pages/home/cards/bar_card.dart pages/home/foo_dialog.dart pages/settings/settings_page.dart . I like to keep it as flat as possible, avoid creating categories that don’t add meaning to a particular file. .",
    "url": "/docs/architecture/project_structure.html",
    "relUrl": "/docs/architecture/project_structure.html"
  }
  ,"25": {
    "title": "RawObject",
    "content": "RawObject . Under the hood all managed objects in DartVM are called RawObjects, in true DartVM fashion these classes are all defined in a single 3,000 line file found at vm/raw_object.h. . In generated code you can access and move around RawObject*s however you want as long as you yield according to an incremental write barrier mask, the GC appears to be able to track references through passive scanning alone. . Here is the class tree: . . RawInstances are the traditional Objects you pass around Dart code and invoke methods on, all of them have an equivalent type in dart land. Non-instance objects however are internal and only exist to leverage reference tracking and garbage collection, they do not have equivalent dart types. . Each object starts with a uint32_t containing the following tags: . . Class IDs here are the same as before with cluster serialization, they are defined in vm/class_id.h but also include user-defined starting at kNumPredefinedCids. . Size and GC data tags are used for garbage collection, most of the time they can be ignored. . If the canonical bit is set that means that this object is unique and no other object is equal to it, like with Symbols and Types. . Objects are very light and the size of RawInstance is usually only 4 bytes, they surprisingly do not use virtual methods at all either. . All of this means allocating an object and filling in its fields can be done virtually for free, something we do quite lot in Flutter. .",
    "url": "/docs/reverse-engineering/rawobject.html",
    "relUrl": "/docs/reverse-engineering/rawobject.html"
  }
  ,"26": {
    "title": "Render Layer",
    "content": "Render Layer . Before continuing, I highly recommend reading the documentation for RenderObject, RenderBox, and Element. . TODO .",
    "url": "/docs/framework/render-layer.html",
    "relUrl": "/docs/framework/render-layer.html"
  }
  ,"27": {
    "title": "Safe Async",
    "content": "Safe Async . Common mistake . Quite frequently I see code using FutureBuilder or StreamBuilder incorrectly: . StreamBuilder&lt;DocumentSnapshot&gt;( stream: Firestore.instance.collection(&#39;foobar&#39;).snapshots(), builder: (context, snapshot) { if (snapshot.hasData) { return Text(&#39;${snapshot.data}&#39;); } else { return CircularProgressIndicator(); } }, ) . Despite looking quite innocent, this is problematic for a few reasons: . Errors from the AsyncSnapshot are silently ignored. | An async task is started during build, which will re-start when rebuilt. | Direct query instead of a request through state management or a network layer. | Thankfully these issues are easy to fix, the rest of this post provides in-depth suggestions for each. . . Error handling . FutureBuilder and StreamBuilder have flaws when it comes to error handling, the only way to know if an error has occurred is to manually either: . Use Future.catchError or Stream.handleError, requiring an extra closure. | Print the error in the AsyncSnapshot without a stack trace, duplicating the message when it rebuilds. | This is far from ideal, thankfully there is a better solution in package:async_builder. This package provides the AsyncBuilder Widget which allows you to rewrite the above code to the following: . AsyncBuilder&lt;DocumentSnapshot&gt;( stream: Firestore.instance.collection(&#39;foobar&#39;).snapshots(), waiting: (context) =&gt; CircularProgressIndicator(), builder: (context, data) =&gt; Text(&#39;$data&#39;), ) . This will properly handle errors emitted by the stream or future, including printing the stack trace and other debug information like where the widget is located in the tree. . That solves error handling, but this sample code still has another flaw which is that building it has side effects. . . Avoiding build side effects . If you call a function directly to start an asynchronous task during build, that task will restart whenever the widget re-builds, potentially causing loss of state, infinite loops, and annoying flashes. . So starting asynchronous tasks like Firestore.instance.collection(&#39;foobar&#39;).snapshots() during build is bad practice, what should we do instead? . The two approaches I will cover are: . The widget solution | The state management solution | . The Widget solution . The most basic solution is to create a new StatefulWidget and start the asynchronous task inside of initState. . class _MyWidetState extends State&lt;MyWidet&gt; { Stream&lt;DocumentSnapshot&gt; foobar; @override void initState() { super.initState(); foobar = Firestore.instance.collection(&#39;foobar&#39;).snapshots(); } @override Widget build(BuildContext context) =&gt; AsyncBuilder( stream: foobar, builder: (context, snapshot) =&gt; ..., ); } . Now our request will not restart every build, nice! . We can do better though, package:async_builder also includes InitBuilder which is a widget that can initialize and cache our stream safely. . Instead of creating a whole new StatefulWidget, we can do this instead: . class MyWidget extends StatelessWidget { static Stream&lt;DocumentSnapshot&gt; getFoobar() =&gt; Firestore.instance.collection(&#39;foobar&#39;).snapshots(); @override Widget build(BuildContext context) =&gt; InitBuilder( getter: getFoobar, builder: (context, stream) =&gt; AsyncBuilder&lt;DocumentSnapshot&gt;( stream: stream, waiting: (context) =&gt; ..., builder: (context, snapshot) =&gt; ..., ), ); } . Making getFoobar static here is important, if we pass it an anonymous function directly it would be forced to make the request every build because the closure instance would be different. . But what if your getter takes arguments, like requesting from an http api for example? . With StatefulWidget, this is a bit involved because you have to check if the key changed after being rebuilt: . class MyWidget extends StatefulWidget { MyWidget({this.keyName}); final String keyName; @override _MyWidgetState createState() =&gt; _MyWidgetState(); } class _MyWidetState extends State&lt;MyWidet&gt; { Future&lt;String&gt; future; void updateFuture() { future = api.getString(widget.keyName); } @override void initState() { super.initState(); updateFuture(); } @override void didUpdateWidget(MyWidget oldWidget) { if (widget.keyName != oldWidget.keyName) { updateFuture(); } } @override Widget build(BuildContext context) =&gt; AsyncBuilder( stream: future, builder: (context, value) =&gt; Text(&#39;$value&#39;), ); } . With the InitBuilder.arg constructor this can be rewritten as: . class MyWidget extends StatelessWidget { MyWidget({this.keyName}); final String keyName; @override Widget build(BuildContext context) =&gt; InitBuilder.arg&lt;String, String&gt;( getter: api.getString, arg: keyName, builder: (context, future) =&gt; AsyncBuilder( future: future, builder: (context, value) =&gt; Text(&#39;$value&#39;), ), ); } . And you are done! The last four examples are safe to use. . . The state management solution . Using state management here has two benefits, first it allows you to avoid multiple widgets requesting snapshots at the same time, second it allows you swap out the underlying supplier of information whether it be for tests or to migrate away from firebase. . For a continuously updating resource, package:rxdart BehaviorSubjects are a very nice way to hold a value and notify listeners at the same time: . class MyService { ... BehaviorSubject&lt;Foobar&gt; _foobar; // Don&#39;t forget to dispose! ValueStream&lt;Foobar&gt; get foobar =&gt; _foobar ??= BehaviorSubject&lt;Foobar&gt;()..addStream( Firestore.instance .collection(&#39;foobar&#39;).snapshots().map((e) =&gt; Foobar.fromJson(e.data)) ); ... } . This basically just creates a BehaviorSubject that wraps snapshots from the firestore, allowing listeners to have an up to date Foobar without making any new requests. . The important part is that the instance is cached, which is very important to prevent side effects. . AsyncBuilder&lt;DocumentSnapshot&gt;( stream: MyService.of(context).foobar, waiting: (context) =&gt; CircularProgressIndicator(), builder: (context, data) =&gt; Text(&#39;$data&#39;), ) . With AsyncBuilder, the builder can use the current value of our BehaviorSubject on first build, avoiding the single-frame loading indicator that StreamBuilder would show. . If you want something a bit lighter consider using ValueNotifier / ValueListenableBuilder instead. . But what if you are requesting something based on its key like in the last two StatefulWidget examples? . What I typically do in this case is cache the futures or streams in a map: . class MyService { ... final MyApi api; var _foobars = &lt;String, Future&lt;Foobar&gt;&gt;{}; Future&lt;Foobar&gt; getFoo(String key) =&gt; _foobars[key] ??= api.getFoobar(key) ..then((value) =&gt; _foobars[key] = SynchronousFuture(value)); ... } . Like before, any tasks created by the service are cached to ensure work isn’t being duplicated. . I’m assigning SynchronousFuture because it allows the value to be available on first build if cached, similar to the ValueStream example. . class MyWidget extends StatelessWidget { MyWidget({this.keyName}); final String keyName; @override Widget build(BuildContext context) =&gt; AsyncBuilder&lt;Foobar&gt;( future: MyService.of(context).getFoo(keyName), waiting: (context) =&gt; CircularProgressIndicator(), builder: (context, data) =&gt; Text(&#39;$data&#39;), ); } . These are some basic patterns that may or may not apply to your use case, if there is anything missing or if you have questions please don’t hesitate to ping me on Discord. . .",
    "url": "/docs/architecture/safe-async.html",
    "relUrl": "/docs/architecture/safe-async.html"
  }
  ,"28": {
    "title": "Single Child Render Objects",
    "content": "Single Child Render Objects . In this post, we will implement a basic single-child render box from scratch. . . SingleChildRenderObjectWidget . To keep it simple, all this widget will do is lay itself out like a square: . /// A container that sizes itself as a square depending on the largest dimension /// of the child, centering it. class Square extends SingleChildRenderObjectWidget { Square({ Key key, Widget child, }) : super( key: key, child: child, ); @override RenderObject createRenderObject(BuildContext context) =&gt; RenderSquare(); } . . RenderBox . Now we create the RenderBox implementation and mixin RenderObjectWithChildMixin for convenience: . class RenderSquare extends RenderBox with RenderObjectWithChildMixin&lt;RenderBox&gt; { ... . The core of the render layer is layout and paint, RenderObjects implement their layout logic in the performLayout method: . @override void performLayout() { if (child == null) { // RenderObjects must have a size after layout, and that size // be within the constraints provided to it. // // Since there is no child, just use the smallest allowed. size = constraints.smallest; } else { // If a RenderObject has a child, it must be layed out at // least once. // // The constraints parameter tells the child what the upper // and lower bounds of its size can be, just like how we // handle incoming constraints to RenderSquare. The child&#39;s // size is forced to fit these constraints, even if it leads // to overpainting or other layout problems. // // A child&#39;s size can only be used by us if it has been // layed out AND parentUsesSize is true. In situations where // our layout does not depend on the size of the child, the // parentUsesSize argument can be false. child.layout(constraints, parentUsesSize: true); // Now that the child has been layed out, we can grab its size. final childSize = child.size; // Calculate the width of our square by taking the maximum of // the child&#39;s width and height. final width = max(childSize.width, childSize.height); // Size ourselves to the closest size that still fits within // the constraints given by our parent. size = constraints.constrain(Size.square(width)); // Each RenderObject has a `parentData` field that is managed // by its parent, this is initialized when the child is mounted // with our `setupParentData` method. The default implementation // for `RenderBox.setupParentData` initializes the child&#39;s // parentData field with a BoxParentData. // // In this case, we use BoxParentData to give the child a // paint offset, this offset can then read by other methods // like `paint` and `applyPaintTransform`. final parentData = child.parentData as BoxParentData; // Center the child vertically and horizontally into our size. parentData.offset = Offset( (size.width - childSize.width) / 2, (size.height - childSize.height) / 2, ); } } . Finally, implement the paint method: . @override void paint(PaintingContext context, Offset offset) { if (child != null) { // Paint always happens after the layout phase is complete, // so we can safely access the parentData from before. final parentData = child.parentData as BoxParentData; // We call PaintingContext.paintChild to paint the child, // you can paint a specific child either once or not at all // per frame. context.paintChild(child, parentData.offset + offset); } } . . Result . When combined with ClipOval and Container, this creates a perfectly circular bubble that matches the size of its child: . . Live demo: https://dartpad.dartlang.org/40622dd3145144d1535e9dab0ee5ea63 . . Add effects . What if our RenderObject needs some extra properties? . First, add the property to the Widget, in this case an opacity: . final double opacity; Square({ Key key, Widget child, this.opacity = 1.0, }) : super( key: key, child: child, ); . Then modify createRenderObject so that it constructs RenderSquare with opacity: . @override RenderObject createRenderObject(BuildContext context) =&gt; RenderSquare(opacity: opacity); . In order for RenderSquare to update when the widget configuration changes, implement the updateRenderObject method: . /// This function is called when a new widget instance /// is provided from a rebuild. @override void updateRenderObject(BuildContext context, RenderSquare renderObject) { renderObject.opacity = opacity; } . In RenderSquare, implement the opacity property: . RenderSquare({ double opacity = 1.0, }) : _opacity = opacity; double _opacity; double get opacity =&gt; _opacity; set opacity(double value) { // Do an early return if the value is the same, this prevents // any redundant repaints or relayouts. // // This kind of early return is actually one of the most // important optimizations in the render layer. if (_opacity == value) return; // Set the real opacity value. _opacity = value; // Here we notify the framework of changes to our // configuration, in this case the update is purely visual // so we call `markNeedsPaint`. // // If this property affects layout we would call // `markNeedsLayout` instead, which does a relayout + repaint. markNeedsPaint(); } . Finally, this property can be used in paint to change the opacity of the child: . @override void paint(PaintingContext context, Offset offset) { if (child != null) { // Paint always happens after the layout phase is complete, // so we can safely access the parentData from before. final parentData = child.parentData as BoxParentData; // Opacity layers use an 8 bit alpha, rather than a float. // // This function just clamps, scales, and rounds a 0 - 1 // opacity value to what the layer expects. final alpha = Color.getAlphaFromOpacity(opacity); // RenderObjects do not just paint to a canvas like you would // expect from a low level graphics library, instead they build // a tree of `Layer`s. // // Because many widgets do need a canvas to paint on, the // `PaintingContext` interface provides a way for many objects // to opportunistically share the same CanvasLayer, which stops // recording when you push your own layer, e.g. OpacityLayer. // // The side effect of this opportunistic sharing is that the // canvas it gives you must be restored before painting a child, // and before you return from `paint`. // // These layers can contain external textures such as native // views, they are also used as a way to efficiently update // specific features without repainting e.g. simple offsets // with OffsetLayer. // // This means in order to apply any paint effects to a child, // we have to push a layer underneath it. In this case, we push // an OpacityLayer. context.pushOpacity(offset, alpha, (context, offset) { // Everything painted in the following callback will have an // opacity effect. context.paintChild(child, parentData.offset + offset); }); } } /// Because our paint function pushes a layer during paint, we need /// to set this to true. /// /// Alternatively if the compositing is conditional, we could compute /// that condition here and call `markNeedsCompositingBitsUpdate` /// in set:opacity when it changes value. /// /// See the implementation of `RenderOpacity` for more details. @protected bool get alwaysNeedsCompositing =&gt; true; . Final result . The final result is a square that also changes its opacity: . . Live demo: https://dartpad.dartlang.org/0d12f9092860c0793e57eb3b9cad2926 .",
    "url": "/docs/framework/single-child-render-objects.html",
    "relUrl": "/docs/framework/single-child-render-objects.html"
  }
  ,"29": {
    "title": "Snapshots",
    "content": "Snapshots . The Dart SDK is highly versatile, you can embed Dart code in many different configurations on many different platforms. . The simplest way to run Dart is to use the dart executable which just reads dart source files directly like a scripting language. It includes the primary components we call the front-end (parses Dart code), runtime (provides the environment for code to run in), and the JIT compiler. . You can also use dart to create and execute snapshots, a pre-compiled form of Dart which is commonly used to speed up frequently used command line tools (like pub). . #lint shell ping@debian:~/Desktop$ time dart hello.dart Hello, World! real 0m0.656s user 0m0.920s sys 0m0.084s ping@debian:~/Desktop$ dart --snapshot=hello.snapshot hello.dart ping@debian:~/Desktop$ time dart hello.snapshot Hello, World! real 0m0.105s user 0m0.208s sys 0m0.016s . As you can see, the start-up time is significantly lower when you use snapshots. . The default snapshot format is kernel, an intermediate representation of Dart code equivalent to the AST. . When running a Flutter app in debug mode, the flutter tool creates a kernel snapshot and runs it in your android app with the debug runtime + JIT. This gives you the ability to debug your app and modify code live at runtime with hot reload. . Unfortunately for us, using your own JIT compiler is frowned upon in the mobile industry due to increased concerns of RCEs. iOS actually prevents you from executing dynamically generated code like this entirely. . There are two more types of snapshots though, app-jit and app-aot, these contain compiled machine code that can be initialized quicker than kernel snapshots but aren’t cross-platform. . The final type of snapshot, app-aot, contains only machine code and no kernel. These snapshots are generated using the gen_snapshots tool found in flutter/bin/cache/artifacts/engine/&lt;arch&gt;/&lt;target&gt;/, more on that later. . They are a little more than just a compiled version of Dart code though, in fact they are a full “snapshot” of the VMs heap just before main is called. This is a unique feature of Dart and one of the reasons it initializes so quickly compared to other runtimes. . Flutter uses these AOT snapshots for release builds, you can see the files that contain them in the file tree for an Android APK built with flutter build apk: . #lint shell ping@debian:~/Desktop/app/lib$ tree . . ├── arm64-v8a │ ├── libapp.so │ └── libflutter.so └── armeabi-v7a ├── libapp.so └── libflutter.so . Here you can see the two libapp.so files which are a64 and a32 snapshots as ELF binaries. . The fact that gen_snapshots outputs an ELF / shared object here might be a bit misleading, it does not expose dart methods as symbols that can be called externally. Instead, these files are containers for the “clustered snapshot” format but with compiled code in the separate executable section, here is how they are structured: . #lint shell ping@debian:~/Desktop/app/lib/arm64-v8a$ aarch64-linux-gnu-objdump -T libapp.so libapp.so: file format elf64-littleaarch64 DYNAMIC SYMBOL TABLE: 0000000000001000 g DF .text 0000000000004ba0 _kDartVmSnapshotInstructions 0000000000006000 g DF .text 00000000002d0de0 _kDartIsolateSnapshotInstructions 00000000002d7000 g DO .rodata 0000000000007f10 _kDartVmSnapshotData 00000000002df000 g DO .rodata 000000000021ad10 _kDartIsolateSnapshotData . The reason why AOT snapshots are in shared object form instead of a regular snapshot file is because machine code generated by gen_snapshot needs to be loaded into executable memory when the app starts and the nicest way to do that is through an ELF file. . With this shared object, everything in the .text section will be loaded into executable memory by the linker allowing the Dart runtime to call into it at any time. . You may have noticed there are two snapshots: the VM snapshot and the Isolate snapshot. . DartVM has a second isolate that does background tasks called the vm isolate, it is required for app-aot snapshots since the runtime can’t dynamically load it in as the dart executable would. .",
    "url": "/docs/reverse-engineering/snapshots.html",
    "relUrl": "/docs/reverse-engineering/snapshots.html"
  }
  ,"30": {
    "title": "Timeline",
    "content": "Timeline . The most useful tool for analyzing performance is the Observatory timeline, you can use it to quickly locate and diagnose problematic frames. . Unfortunately the observatory button was removed by the Flutter plugin, see IntelliJ Observatory for an easy way to open it again. . Keep in mind timelines can be skewed by external factors such as low memory, it’s always good to double check by enabling performance overlays in the developer options. . . Why not DevTools? . The DevTools timeline is also nice, but it has some limitations like not being able to get the class name of a sample. It also lacks the ability to analyze live objects, which is extremely helpful for tracking down memory leaks. . Until DevTools has feature parity, I would recommend learning how to use the Observatory instead. . . Workflow . My general workflow goes as follows: . Run the app in profile mode. | Open the observatory. | Click “view timeline” under VM information. . . | Click “Flutter Developer”: . . | Prepare the device to produce problematic frames e.g. open the ListView. | Click clear in the top right. . . | Perform the action that produces problematic frames. | Click refresh. | Use the pan and zoom tools to locate a bad frame: . . Make sure you scroll vertically to the ui and raster threads, bad frames will stick out like this: . . | For ui thread problems like shown above, click the timeline event and then find the overlapping samples: . . | Locate problematic functions in the samples below: . . Here we can see the root cause of the jank, I’m doing too much work in a closure in _HomePageState.build. . | . Complex widgets . Unfortunately the culprit might not be a single function, but instead emerge from large complex widgets. . TODO .",
    "url": "/docs/performance/timeline.html",
    "relUrl": "/docs/performance/timeline.html"
  }
  ,"31": {
    "title": "Type system",
    "content": "Type system . What are types? . A type is a node used to describe the interface an instance can have, here are a few examples: . // Foo is now an interface type. class Foo {} // FooFn is now an alias of the `Foo Function()` type. typedef FooFn = Foo Function(); // You can now create interface types of Bar with any subtype of Foo as the type argument. class Bar&lt;T extends Foo&gt; { // T is a subtype of Foo in this context. } . At the highest level, there are only a handful kinds of types: . dynamic | void | interface types | function types | parameter types | The most common is interface types, which describe a class and resolved type arguments. . dart:core contains a bunch of classes with special type properties, I’ll cover those below. . . Instances . Throughout an object’s lifetime, it has a single type, this type is determined when constructed and can never be changed: . int x = 2; num y = x; print(x is int); // true print(y is int); // true int z = y as int; // works . The type used to declare a variable is only the interface, it can store any assignable instance that implements said interface. . . Methods . When you call a method on an instance, the type the instance was created with always determines the implementation of that method, for example: . class Foo { void hi() =&gt; print(&quot;i am foo&quot;); } class Bar implements Foo { void hi() =&gt; print(&quot;i am bar&quot;); } void callHi(Foo foo) =&gt; foo.hi(); void main() { callHi(Bar()); // prints &quot;i am bar&quot; } . Here, Bar’s implementation of hi will always override calls from its instances, regardless of what context its in. . All types visible to dart code are a subtype of Object and inherit the default implementation of its interface. . Dart is strongly typed, that means the compiler can make strong guarantees about the type a value will have at runtime. . Strong typing does not mean methods are guaranteed to exist though, if a method is missing when called, dart calls the noSuchMethod method which will throw a NoSuchMethodError by default. . (42 as dynamic).foo(); // throws NoSuchMethodError . All field access on instances is done through calls to setter and getter methods. . When you declare a field inside of a class, it implicitly declares setter and getter methods that read and write to an internal variable. This is different from C# for example, where setters / getters and fields are incompatible declarations. . class Foo { int a; // This declares both set:a and get:a } class Bar extends Foo { int get a =&gt; super.a * 2; // This overrides get:a without touching set:a } main() { var foo = Bar(); foo.a = 2; print(foo.a); // prints 4 } . . Assignability . A variable can contain values that are not actual subtypes of its declared type, specifically null: . int x; print(x is int); // false . This prints false because the is operator is a subtype check, not an assignability check. . The as operator on the other hand does do an assignability check: . int x; print(x as int); // null, works . This is because a value x is assignable to T if either: . x’s runtime type is a subtype of T. | x is null and T is nullable. | . Null vs void vs dynamic vs Object . The Null class is special, it throws a formatted NoSuchMethodError when methods other than get:hashCode, get:runtimeType, and operator== are called. . The dynamic and void types are both effectively an alias for Object, but change how visible methods are: . With Object, you can only access methods from the Object interface (just like a regular class), i.e. hashCode. | With void, you can store and cast, but not access any methods. | With dynamic, you can access any methods and call it with any arguments, those return values are also treated as dynamic. | . . Closures . Extraction is the process of taking an instance method and turning it into a closure, this is commonly called a tear-off. . Methods can be extracted by calling the getter with their name: . typedef ToStringFn = String Function(); ToStringFn getToString(Object x) =&gt; x.toString; . In this example we extract the toString method from an arbitrary object x, giving us a closure that can be called as if it was a regular instance call on x. . The above code is effectively the same thing as: . typedef ToStringFn = String Function(); ToStringFn getToString(Object x) =&gt; () =&gt; x.toString(); . Except the former is a bit more efficient. . Functions are very special, they can actually refer to two different things: . Function types declared with arguments and return type, i.e. void Function() foo;. | The Function class as an interface type, which is a super type of any function. | Function types are similar to generic interface types, but can describe parameter names and types. . All function types are subtypes of Function, regardless of their return type and arguments: . print(print is Function); // true . . Callable classes . Classes can be callable… kinda. . class Foo { void call() =&gt; print(&#39;hi&#39;); } void main() { Foo()(); // prints &quot;hi&quot; } . This is actually a little deceiving, Foo instances themselves are not actually callable, what’s happening is that the call method is being implicitly extracted. . Implicit tear-offs have some caveats, for example: . void callFoo(void Function() x) { print(x is Foo); // false print(x is Function); // true x(); } void main() { var x = Foo(); print(x is Foo); // true print(x is Function); // false callFoo(x); } . The x here seems to be in a superposition between being Foo and being Function, this is because x is being implicitly converted into a closure before being passed to callFoo. .",
    "url": "/docs/faq/type-system.html",
    "relUrl": "/docs/faq/type-system.html"
  }
  
}